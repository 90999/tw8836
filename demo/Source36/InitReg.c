#include "Config.h"
#include "reg.h"
#include "typedefs.h"
#include "TW8836.h"

#include "Global.h"
#include "CPU.h"
#include "Printf.h"
#include "util.h"
#include "Monitor.h"

#include "I2C.h"
#include "SPI.h"

#include "main.h"
#include "SOsd.h"
#include "FOsd.h"
#include "Scaler.h"
#include "decoder.h"
#include "InputCtrl.h"
#include "EEPROM.h"
#include "ImageCtrl.h"
#include "decoder.h"
#include "InputCtrl.h"
#include "OutputCtrl.h"
#include "Settings.h"
#include "measure.h"
//#include "SOsdMenu.h"
#ifdef SUPPORT_COMPONENT
#include "data\DataComponent.inc"
#endif
#include "BT656.h"

typedef struct REG_IDX_DATA_s
{
	WORD idx;
	BYTE value;
} REG_IDX_DATA_t;

/*
	Default register value.
*/
code REG_IDX_DATA_t InitDefault_Table[] = 
{
	//-----------------
	//clock
	{0x4E1, 0x01},
	{0x4E0, 0x01},
	//-----------------
	//SSPLL
	{0x0F6, 0x00},
	{0x0F7, 0x16},

//#ifdef PANEL_AUO_B133EW01
//	{0x0F8, 0x02},	//150MHz. PCLKO target 75MHz
//	{0x0F9, 0xC7},
//	{0x0FA, 0x1D},
////	{0x0F8, 0x02},	//140MHz. PCLKO target 70MHz
////	{0x0F9, 0x97},
////	{0x0FA, 0xB4},
//#else
	{0x0F8, 0x02},
	{0x0F9, 0x00},
	{0x0FA, 0x00},
//#endif
	
	{0x0FB, 0x40},
	{0x0FC, 0x23},
	{0x0FD, 0x34},
	
	//-----------------
	//pclko divider. NOTE: update twice.
//#ifdef PANEL_AUO_B133EW01
//	{0x20D, 0x91},	//div2. 150/2=75MHz
//					//		140/2=70MHz	
//#else
	{0x20D, 0x92},	
//#endif

	//-----------------
	//interrupt
	{0x003, 0xFF},	//mask first.
	{0x002, 0xFF},  //and than clear.

	{0x006, 0x06},
	//-----------------
	//output
								//R007[3]:EN656OUT
								//R007[2:0]:TCONSEL.  TCON pin output
//#ifdef SUPPORT_BT656
//#if defined(PANEL_SRGB)
//	{0x007,	0x09},
//#elif defined(PANEL_FP_LSB)
//	{0x007,	0x0A},
//#else
//	{0x007,	0x08},	
//#endif		
//#else
#if defined(PANEL_AUO_B133EW01)
	{0x007, 0x10},				//It is a LVDS, so dont care Output.
								//but, it needs 2bit shift down.
#elif defined(PANEL_SRGB)
	{0x007,	0x01},
#elif defined(PANEL_FP_LSB)
	{0x007,	0x02},
#else
	{0x007,	0x80},
#endif		
//#endif
								//R008[5]:TRI_FPD
								//R008[4]:TRI_EN
//BK121216. TCPOLP use TEST_GPO to support Remocon on INT11.
//we are using REG008[7:6]=10b. 4mA or 8mA.
//	{0x008,	0x79},
	{0x008,	0xB6},	//4mA. TRI_FPD, TRI_EN.	GPOSEL=tcpol
					//-----------------
	{0x01F, 0x00},	//disable test mode

					//-----------------
	{0x040,	0x10},	//input control I
	{0x041,	0x0C},	//input control I

	//-----------------
	//input crop
	//0x042
	//0x043
	//0x044
	//0x045
	//0x046
	{0x047, 0x00},

	//-----------------
	//BT656  decoder
	//{0x048, },
	//

	//-----------------
	//DTV
	{0x057, 0x00},
					//-----------------
	{0x05F, 0x00},	// disable test pattern

	//-----------------
	//GPIO
	{0x080, 0x00},
	{0x081, 0x00},
	{0x082, 0x00},
	{0x083, 0x00},
	{0x084, 0x00},
	{0x085, 0x00},
	{0x086, 0x00},
	{0x087, 0x00},
	{0x088, 0x00},
	{0x089, 0x00},
	{0x08A, 0x00},
	{0x08B, 0x00},
	{0x08C, 0x00},
	{0x08D, 0x00},
	{0x08E, 0x00},
	{0x08F, 0x00},
	{0x090, 0x00},
	{0x091, 0x00},
	{0x092, 0x00},
	{0x093, 0x00},
	{0x094, 0x00},
	{0x095, 0x00},
	{0x096, 0x00},
	{0x097, 0x00},
	{0x098, 0x00},
	{0x099, 0x00},
	{0x09A, 0x00},
	{0x09B, 0x00},
	{0x09C, 0x00},
	{0x09D, 0x00},
	{0x09E, 0x00},
	{0x09F, 0x00},
	//-----------------
	//MBIST
	{0x0A0, 0x00},
	//-----------------
	//TSC
	{0x0B0, 0x87},
	{0x0B1, 0xC0},
	{0x0B4, 0x0A},
	//-----------------
	//LOPOR
	{0x0D4, 0x00},
	//-----------------
	//PWM
	{0x0D6, 0x00},
					
	//-----------------
	//decoder
	{0x102, 0x00},	//depend on input
	{0x104, 0x00},
	{0x105, 0x00},
	{0x106, 0x03},				
	{0x107, 0x02},	// decoder input crop.
	{0x108, 0x12},
	{0x109, 0xF0},
	{0x10A, 0x0B},
	{0x10B, 0xD0},
	{0x10C, 0xCC},	//DEC:0xCC,	aRGB:0xCC
	{0x10D, 0x00},
	{0x110, 0x00},	//color
	{0x111, 0x5C},
	{0x112, 0x11},
	{0x113, 0x80},
	{0x114, 0x80},
	{0x115, 0x00},  
	{0x117, 0x30},
	{0x118, 0x44},
	{0x11A, 0x00},
	{0x11C, 0x07},
	{0x11D, 0x7F},
	{0x11E, 0x00},
	{0x120, 0x50},
	{0x121, 0x22},
	{0x122, 0xF0},
	{0x123, 0xD8},
	{0x124, 0xBC},
	{0x125, 0xB8},
	{0x126, 0x44},
	{0x127, 0x38},
	{0x128, 0x00},
	{0x129, 0x00},
	{0x12A, 0x78},
	{0x12B, 0x44},
	{0x12C, 0x30},
	{0x12D, 0x14},
	{0x12E, 0xA5},
	{0x12F, 0xE0},
	{0x133, 0x05},
	{0x134, 0x1A},
	{0x135, 0x00},
	{0x136, 0x03}, //??
	{0x137, 0x28}, //??
	{0x138, 0xAF}, //??

	//-----------------
	//LLPLL
	{0x1C0, 0x00},	
	{0x1C2, 0xD2},
	{0x1C3, 0x03},
	{0x1C4, 0x5A},
	{0x1C5, 0x00},
	{0x1C6, 0x20},
	{0x1C7, 0x04},
	{0x1C8, 0x00},
	{0x1C9, 0x06}, //??
	{0x1CA, 0x06}, //??
	{0x1CB, 0x16}, //->D6 or F6
	{0x1CC, 0x00},
	{0x1CD, 0x54},

	{0x1D0, 0x00},
	{0x1D1, 0xF0},
	{0x1D2, 0xF0},
	{0x1D3, 0xF0},
	{0x1D4, 0x20},	//use rising.
	{0x1D5, 0x00},
	{0x1D6, 0x10},
	{0x1D7, 0x00}, //??0x70
	{0x1D8, 0x00},
	{0x1D9, 0x02},
	{0x1DA, 0x80},
	{0x1DB, 0x80},
	{0x1DC, 0x10}, //??0x10

	{0x1E0, 0x00}, 
	{0x1E1, 0x05},	//1E1[5]:GPLL_PD

	{0x1E2, 0x59},
	{0x1E3, 0x37},	//DEC:0x07, aREG:0x37
	{0x1E4, 0x55},	//DEC:0x33, aREG:0x55
	{0x1E5, 0x55},	//DEC:0x33, aRGB:0x55
	{0x1E6, 0x20},	//DEC:0x00, aRGB:0x20
	{0x1E7, 0x2A},
	{0x1E8, 0x20},	//DEC:0x0F, aRGB:0x00
	{0x1E9, 0x00},
	{0x1EA, 0x03},

	//-----------------
	//scaler
	{0x201, 0x00},	
	{0x202, 0x20},	
	{0x203, 0x00},
	{0x204, 0x20},
	{0x205, 0x00},
	{0x206, 0x10},	
	{0x207, 0x40},	
	{0x208, 0x20},
	{0x209, 0x00},	
	{0x20A, 0x04},
	{0x20B, 0x10},	//0x30
	{0x20C, 0x20},		
//#if defined(PANEL_AUO_B133EW01)
//	{0x20D, 0x91},	//div2
//#else
	{0x20D, 0x92},
//#endif
	{0x20E, 0x30},
	{0x20F, 0x02},	//0x00
	{0x210, 0x30},	//0x21  BK130122

#if (PANEL_H == 1280)
	{0x211, 0x01},	//1280+1
	{0x212, 0x05},
#else
	{0x211, 0x21},
	{0x212, 0x03},
#endif

	{0x213, 0x00},	 //0x10
	{0x214, 0x0A},	 //0x20
	{0x215, 0x20},

#if (PANEL_V==800)
	{0x216, 0x20},	//800
	{0x217, 0x03},
#else
	{0x216, 0xE0},
	{0x217, 0x01},
#endif

	{0x218, 0x00},
	{0x219, 0x27},
	{0x21A, 0x00},
	{0x21B, 0x00},
	{0x21C, 0x42},
	{0x21D, 0x3E},
	{0x21E, 0x02},
	{0x220, 0x00},
	{0x221, 0x00},

	//-----------------
	// scaler output timing. for No video at first time.
	//-----------------
	//TCON
	{0x240, 0x10},
	{0x241, 0x00},
	{0x242, 0x05},
	{0x243, 0x01},
	{0x244, 0x64},
	{0x245, 0xF4},
	{0x246, 0x00},
	{0x247, 0x0A},
	{0x248, 0x36},
	{0x249, 0x10},
	{0x24A, 0x00},
	{0x24B, 0x00},
	{0x24C, 0x00},
	{0x24D, 0x44},
	{0x24E, 0x04},

	//-----------------
	//Image Adjustment
	{0x280, 0x20},
	{0x281, 0x80},
	{0x282, 0x80},
	{0x283, 0x80},
	{0x284, 0x80},
	{0x285, 0x80},
	{0x286, 0x80},
	{0x287, 0x80},
	{0x288, 0x80},
	{0x289, 0x80},
	{0x28A, 0x80},
	{0x28B, 0x40},
	{0x28C, 0x00},

	//-----------------
	//Test Pattern
	{0x2BF, 0x00},
	//-----------------
	//Gamma
	{0x2E0, 0x00}, 
	//-----------------
	//Dither option
	{0x2E4, 0x21},
	//-----------------
	//8bit PANEL Interface
	{0x2F8, 0x00},
	{0x2F9, 0x80},

	//-----------------
	//FOSD
// Font download have to be exec when 
//	{0x30C, 0x40},
	{0x30C, 0x00},	//turn on FOSD
	{0x310, 0x00},	//deable WIN1..WIN8
	{0x320, 0x00},
	{0x330, 0x00},
	{0x340, 0x00},
	{0x350, 0x00},
	{0x360, 0x00},
	{0x370, 0x00},
	{0x380, 0x00},
	//-----------------
	//SOSD
	{0x400, 0x00},
	//-----------------
	//LVDS Tx
	{0x640, 0x00},
	{0x641, 0x00},
	{0x642, 0x00},
	//-----------------
	//LVDS Rx
	{0x644, 0x00},
	{0x645, 0x00},
	{0x646, 0x00},
	{0x647, 0x00},
	{0x648, 0x00},
	{0x649, 0x17},
	{0x64A, 0x00},
	{0x64B, 0x00},

	//-----------------
	{0xFFF, 0xFF}	//EOF
};

code REG_IDX_DATA_t Recover_Decoder[] = 
{
	{0x10C, 0xCC},	//DEC:0xDC,	aRGB:0xCC
	{0x1E3, 0x07},	//DEC:0x07, aREG:0x37
	{0x1E4, 0x33},	//DEC:0x33, aREG:0x55
	{0x1E5, 0x33},	//DEC:0x33, aRGB:0x55
	{0x1E6, 0x00},	//DEC:0x00, aRGB:0x20
	{0x1E8, 0x2F},	//DEC:0x0F, aRGB:0x00
	{0xFFF, 0xFF}	//EOF
};

code REG_IDX_DATA_t Recover_aRGB[] =
{
	{0x10C, 0xCC},	//DEC:0xCC,	aRGB:0xCC
	{0x1E3, 0x37},	//DEC:0x07, aREG:0x37
	{0x1E4, 0x55},	//DEC:0x33, aREG:0x55
	{0x1E5, 0x55},	//DEC:0x33, aRGB:0x55
	{0x1E6, 0x20},	//DEC:0x00, aRGB:0x20
	{0x1E8, 0x20},	//DEC:0x0F, aRGB:0x00
	{0xFFF, 0xFF}	//EOF
};

/**
* Description: download indexed register value
* @param
*	pTbl : REG_IDX_DATA pointer.
*/
static void Init8836Register(REG_IDX_DATA_t *pTbl)
{
	while (1)
	{
		if (pTbl->idx == 0xFFF /*&& pTbl->value==0xFF*/)
			break;
		WriteTW88(pTbl->idx, pTbl->value);
		pTbl++;
	}
}

/**
* Description: initialize TW8836 Default value
* @param
*	InputMain : Input Type
*	fPowerOn 1:Powerup boot, 0:input toggle.
*/
void Init8836AsDefault(BYTE _InputMain, BYTE _fPowerOn)
{
	Printf("\nInit8836AsDefault(");
	PrintfInput(_InputMain, 0);
	Printf(",%bx)", _fPowerOn);

	WriteTW88(REG21E, 0x03);		//mute scler output.
 
	if (_fPowerOn)
	{
		Init8836Register(InitDefault_Table);
		I2C_delay_base = 1; //assume 27MHz. see REG4E1[5:4].

		return;
	}

	//Recover only the selected input.

	if (_InputMain == INPUT_CVBS || _InputMain == INPUT_SVIDEO || _InputMain == INPUT_BT656)
		Init8836Register(Recover_Decoder);
	else if (_InputMain == INPUT_COMP || _InputMain == INPUT_PC)
		Init8836Register(Recover_aRGB);
}

/*
	BT656 External Encoder table.
*/
code BYTE BT656_table_8BIT_525I_YCBCR_TO_CVBS[] = {
	I2CID_ADV7390, 0x00,
	0x17, 0x02,
	0x00, 0x1C,
	0x01, 0x00,
	0x80, 0x10,
	0x82, 0xCB,	
	0xFF,0xFF	
};
code BYTE BT656_table_8BIT_625I_YCBCR_TO_CVBS[] = {
	I2CID_ADV7390, 0x00,
	0x17,0x02,
	0x00,0x1c,
	0x01,0x00,
	0x80,0x11,
	0x82,0xC3,
	0x8C,0xCB,
	0x8D,0x8A,
	0x8E,0x09,
	0x8F,0x2A,	
	0xFF,0xFF	
};
code BYTE BT656_table_8BIT_525P_YCBCR_TO_CVBS[] = {
	I2CID_ADV7390, 0x00,
	0x17,0x02,
	0x00,0x1c,
	0x01,0x20,
	0x30,0x04,
	0x31,0x01,
	0xFF,0xFF	
};
code BYTE BT656_table_8BIT_625P_YCBCR_TO_CVBS[] = {
	I2CID_ADV7390, 0x00,
	0x17,0x02,
	0x00,0x1c,
	0x01,0x20,
	0x30,0x1C,
	0x31,0x01,
	0xFF,0xFF	
};
code BYTE BT656_table_8BIT_720P_YCBCR_TO_CVBS[] = {
	I2CID_ADV7390, 0x00,
	0x17,0x02,
	0x00,0x1c,
	0x01,0x20,
	0x30,0x2C,
	0x31,0x01,
	0xFF,0xFF	
};
code BYTE BT656_table_8BIT_1080I_YCBCR_TO_CVBS[] = {
	I2CID_ADV7390, 0x00,
	0x17,0x02,
	0x00,0x1c,
	0x01,0x20,
	0x30,0x6C,
	0x31,0x01,
	0xFF,0xFF	
};


//-----------------------------------------------------------------------------
/*
* init BT656 encoder
*
* TW8835 EVB2.1 and EVB3.1 use ADV7390.
* TW8835 EVB2.0 and EVB3.0 use BU9969.
*
* @param mode
*	0: BT656_8BIT_525I_YCBCR_TO_CVBS	
*	1: BT656_8BIT_625I_YCBCR_TO_CVBS	
*	2: BT656_8BIT_525P_YCBCR_TO_CVBS	
*	3: BT656_8BIT_625P_YCBCR_TO_CVBS	
*	4: BT656_8BIT_720P_YCBCR_TO_CVBS	
*	5: BT656_8BIT_1080I_YCBCR_TO_CVBS
*/
void BT656_InitExtEncoder(BYTE mode)
{
	BYTE *p;
	BYTE addr;

	switch(mode) {
	case BT656_8BIT_525I_YCBCR_TO_CVBS:	
		p = BT656_table_8BIT_525I_YCBCR_TO_CVBS; 
		break;
		break;
	case BT656_8BIT_625I_YCBCR_TO_CVBS:
		p = BT656_table_8BIT_625I_YCBCR_TO_CVBS; 
		break;
	case BT656_8BIT_525P_YCBCR_TO_CVBS:
		p = BT656_table_8BIT_525P_YCBCR_TO_CVBS; 
		break;
	case BT656_8BIT_625P_YCBCR_TO_CVBS:
		p = BT656_table_8BIT_625P_YCBCR_TO_CVBS; 
		break;
	case BT656_8BIT_720P_YCBCR_TO_CVBS:
		p = BT656_table_8BIT_720P_YCBCR_TO_CVBS; 
		break;
	case BT656_8BIT_1080I_YCBCR_TO_CVBS:
		p = BT656_table_8BIT_1080I_YCBCR_TO_CVBS; 
		break;
	default:
		//unknown.
		return;
	}

	addr = p[0]; //ignore counter, p[1].
	p+=2;

	while (( p[0] != 0xFF ) || ( p[1]!= 0xFF )) {			// 0xff, 0xff is a end of data
		WriteI2CByte(addr, p[0], p[1]);
		p+=2;
	}
}

/**
* download component default registers
*
* @param mode
*	0: 480i
*	1: 576i
*	2: 480p
*	3: 576p
*	4: 1080i@25_H28
*	5: 1080i@30
*	6: 720p@50
*	7: 720p@60
*	8: 1080p@50
*	9: 1080p@60
*/
#ifdef SUPPORT_COMPONENT
void InitComponentReg(BYTE mode)
{
	WORD w_page=0;
	BYTE *p;
	BYTE index,value;

	switch(mode) {
	case 0:	p=DataInit_Component_Init480i_step1;	break;
	case 1:	p=DataInit_Component_Init576i_step1;	break;
	case 2:	p=DataInit_Component_Init480p_step1;	break;
	case 3:	p=DataInit_Component_Init576p_step1;	break;
	case 4:	//we can't distinglish H28 and H31. Please select one.
			p=DataInit_Component_Init1080i25_H28_step1;	break;
			//p=DataInit_Component_Init1080i25_H31_step1;	break;
	case 5:	p=DataInit_Component_Init1080i30_step1;		break;
	case 6:	p=DataInit_Component_Init720p50_step1;	 	break;
	case 7:	p=DataInit_Component_Init720p60_step1;		break;
	case 8:	p=DataInit_Component_Init1080p50_H56_step1;	break;
	case 9:	p=DataInit_Component_Init1080p60_step1;	 	break;
	default:
		return;
	}
	p+=2;	//ignore first pair. 
	index = p[0];
	value = p[1];
	while (( index != 0xFF ) || ( value != 0xFF )) {			// 0xff, 0xff is end of data
		if(index==0xFF) {
			w_page =  value;
			w_page  <<= 8;
		}
		else {
			WriteTW88(w_page+index, value);
		}
		p+=2;
		index = p[0];
		value = p[1];
	}
}
#endif

//-----------------------------------------------------------------------------
/**
* print Input string
*/
void PrintfInput(BYTE Input, BYTE debug)
{
	if (debug <= DebugLevel)
	{
		switch (Input)
		{
		case INPUT_CVBS: 	Printf("CVBS"); 				break;
		case INPUT_SVIDEO: 	Printf("SVIDEO"); 				break;
		case INPUT_COMP: 	Printf("Component"); 			break;
		case INPUT_PC: 		Printf("PC"); 					break;
		case INPUT_DVI: 	Printf("DVI"); 					break;
		case INPUT_HDMIPC: 	Printf("HDMIPC"); 				break;
		case INPUT_HDMITV: 	Printf("HDMITV"); 				break;
		case INPUT_BT656: 	Printf("BT656");				break;
		case INPUT_LVDS: 	Printf("LVDSRx");				break;
		default: 			Printf("unknown:%02bd", Input);	break;
		}
	}
}

//			Printf("\nusage: iBT656 {OFF|AUTO|PANEL|DEC|ARGB|DTV|LVDS}");


void PrintfBT656Input(BYTE Input, BYTE debug)
{
	if(debug > DebugLevel)
		return;

	switch(Input) {
	case BT656_SRC_DEC: 	Printf("DEC"); 					break;
	case BT656_SRC_ARGB: 	Printf("ARGB"); 				break;
	case BT656_SRC_DTV: 	Printf("DTV"); 					break;
	case BT656_SRC_LVDS: 	Printf("LVDS"); 				break;
	case BT656_SRC_PANEL: 	Printf("PANEL"); 				break;
	case BT656_SRC_OFF: 	Printf("OFF"); 					break;
	case BT656_SRC_AUTO: 	Printf("AUTO"); 				break;
	default: 				Printf("unknown:%02bd",Input); 	break;
	}
}


code BYTE DataInit_BT656_TEMP0[] = {
/*
echo off
*/
0x00,0x00,

0xFF,0x00,  //; Page 00
0x02,0x6B,
0x03,0xFF,
0x04,0x00,
0x06,0x06,		//0x06,0x00,
0x07,0x08,		//0x07,0x0A,
0x08,0x80,	//??
0x0F,0x00,
0x1F,0x00,

0x40,0x06,
0x41,0x00,
0x42,0x02,
0x43,0x20,
0x44,0xF0,
0x45,0x20,
0x46,0xD0,
0x47,0x00,	//??
0x48,0x00,
0x50,0x00,
0x51,0x08,
0x52,0x02,
0x53,0x00,
0x54,0x00,
0x56,0x00,
0x57,0x00,
0x5F,0x00,
0x60,0x00,
0x66,0x00,
0x67,0x00,
0x68,0x00,
0x69,0x02,
0x6A,0x20,
0x6B,0xF0,
0x6C,0x20,
0x6D,0xD0,
0x6E,0x10,
0x6F,0x10,
0xD4,0x00,

0xF6,0x00,
0xF7,0x16,
0xF8,0x01,	//??
0xF9,0x50,	//??
0xFA,0x00,
0xFB,0x40,
0xFC,0x30,	//??
0xFD,0x61,	//??

0xFF,0xFF
};

code BYTE DataInit_BT656_TEMP1[] = {
0x00,0x00,
	 	  
0xFF,0x01,  //; Page 01
0x01,0x78,
0x02,0x40,
0x04,0x00,
0x05,0x00,
0x06,0x00,
0x07,0x02,
0x08,0x12,
0x09,0xF0,
0x0A,0x0F,
0x0B,0xD0,
0x0C,0xCC,
0x0D,0x00,
0x10,0x00,
0x11,0x5C,
0x12,0x11,
0x13,0x80,
0x14,0x80,
0x15,0x00,
0x17,0x80,
0x18,0x44,
0x1A,0x10,
0x1B,0x00,
0x1C,0x07,
0x1D,0x7F,
0x1E,0x00,
0x1F,0x00,
0x20,0x50,
0x21,0x22,
0x22,0xF0,
0x23,0xD8,
0x24,0xBC,
0x25,0xB8,
0x26,0x44,
0x27,0x38,
0x28,0x00,
0x29,0x00,
0x2A,0x78,
0x2B,0x44,
0x2C,0x30,
0x2D,0x14,
0x2E,0xA5,
0x2F,0xE0,
0x30,0x00,
0x31,0x10,
0x32,0xFF,
0x33,0x05,
0x34,0x1A,
0x35,0x00,
0x36,0xE3,
0x37,0x28,
0x38,0xAF,
0x40,0x00,
0x41,0x80,
0x42,0x00,
0xC0,0x01,
0xC1,0xC7,
0xC2,0x01,
0xC3,0x03,
0xC4,0x5A,
0xC5,0x00,
0xC6,0x20,
0xC7,0x04,
0xC8,0x00,
0xC9,0x06,
0xCA,0x06,
0xCB,0x30,
0xCC,0x00,
0xCD,0x54,
0xD0,0x00,
0xD1,0xF0,
0xD2,0xF0,
0xD3,0xF0,
0xD4,0x00,
0xD5,0x00,
0xD6,0x10,
0xD7,0x70,
0xD8,0x00,
0xD9,0x04,
0xDA,0x80,
0xDB,0x80,
0xDC,0x20,
0xE0,0x00,
0xE1,0x05,
0xE2,0xD9,
0xE3,0x07,
0xE4,0x33,
0xE5,0x31,
0xE6,0x00,
0xE7,0x2A,
0xE8,0x21,
0xE9,0x00,
0xEA,0x03,
0xFF,0xFF
};
	 	  
code BYTE DataInit_BT656_TEMP2[] = {
0x00,0x00,

0xFF,0x02,  //; Page 02

0x01,0x00,
0x02,0x20,
0x03,0x00,
0x04,0x1C,
0x05,0x9F,
0x06,0x0F,
0x07,0x80,
0x08,0x11,
0x09,0x00,
0x0A,0x04,
0x0B,0x1B,
0x0C,0x20,
0x0D,0x00,
0x0E,0x30,
0x0F,0x00,
0x10,0x3E,
0x11,0x20,
0x12,0x03,
0x13,0x10,
0x14,0x20,
0x15,0x2C,
0x16,0xE0,
0x17,0x01,
0x18,0x00,
0x19,0x00,
0x1A,0x00,
0x1B,0x00,
0x1C,0x40,	//??
0x1D,0x4C,	//??
0x1E,0x00,
0x20,0x00,
0x21,0x00,
//0x40,0x10,
//0x41,0x00,
//0x42,0x01,
//0x43,0x00,
//0x44,0x00,
//0x45,0x01,
//0x46,0x00,
//0x47,0x00,
//0x48,0x01,
//0x49,0x10,
//0x4A,0x00,
//0x4B,0x00,
//0x4C,0x10,
//0x4D,0x80,
//0x4E,0x00,

//0xe4,0x21,

//0xF8,0x00,
//0xF9,0x80,

0xFF,0xFF
};
	 	  
code BYTE DataInit_BT656_TEMP6[] = {
0x00,0x00,

0xFF,0x06,  //; Page 06
0x40,0x00,
0x41,0x00,
0x42,0x00,
0x48,0x00,
0x49,0x00,
0x4A,0x00,
0x4B,0x00,
0x4C,0x00,
0x4D,0x00,
0x4E,0x00,
/* echo on */
	0xFF,0xFF
};

void TEMP_init_BT656(BYTE test)
{
	WORD w_page=0;
	BYTE *p;
	BYTE index,value;

	Printf("\nTEMP_init_BT656");

	if(test==0)      p = DataInit_BT656_TEMP0;
	else if(test==1) p = DataInit_BT656_TEMP1;
	else if(test==2) p = DataInit_BT656_TEMP2;
	else if(test==6) p = DataInit_BT656_TEMP6;
	else
		return;
	p+=2;	//ignore first pair. 
	index = p[0];
	value = p[1];
	while (( index != 0xFF ) || ( value != 0xFF )) {			// 0xff, 0xff is end of data
		if(index==0xFF) {
			w_page =  value;
			w_page  <<= 8;
		}
		else {
			WriteTW88(w_page+index, value);
			Printf("\nw %x %bx",w_page+index, value);
		}
		p+=2;
		index = p[0];
		value = p[1];
	}
}
